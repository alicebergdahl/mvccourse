{% extends "base.html.twig" %}

{% block title %}Home{% endblock %}

{% block body %}

<div class="content">
    <div class="row">
        <h1>Redovisning av kursmoment i kursen</h1>
    </div>

    <div class="row">
        <div class="column">
            <div class="item">
                <h2 id="kmom01">Kmom01</h2>
                <p>Jag har tidigare läst om objektorienterad programmering, främst i Python, men jag saknar djupare erfarenhet inom området. Men att strukturera kod objektorienterat hara jag förstått är ett effektivt sätt för att bland annat få mer lättläst kod. </p>
                <p>PHP:s modell för klasser och objekt liknar andra objektorienterade språk. För att komma igång behöver man förstå grundläggande koncept såsom klasser, objekt, arv och instansiering. Det är också viktigt att känna till hur man skapar metoder och egenskaper i klasser. </p>
                <p>Strukturen och koden för uppgiften me/report upplevde jag som komplicerad, jag har bland annat svårt att förstå strukturen av Symfony. Jag stötte på svårigheter med att få CSS att fungera och upplevde problem med att få Symfony att fungera korrekt på studentservern. Jag hade även fullt utrymme på studentservern men som jag förstått det så är det viktiga att koden ligger uppe på github. </p>
                <p>I artikeln tycker jag det var intressant att läsa om PHP:s syntax, hantering av formulär och databaser, samt bästa praxis för säkerhet. Min TIL för detta kursmoment är att jag har lärt mig grunderna i Symfony, även om jag fortfarande känner mig osäker och förvirrad i användningen av ramverket. </p>
            </div>
            <div class="item">
                <h2 id="kmom02">Kmom02</h2>
                <p>I objektorienterad programmering är arv, komposition, interface och trait viktiga koncept för att organisera kod. Arv möjliggör återanvändning av kod genom att en klass kan ärva egenskaper och metoder från en annan. Komposition innebär att en klass innehåller andra klasser som en del av sin struktur. Interface definierar standardiserade gränssnitt för klasser, medan trait tillåter återanvändning av metoder i flera klasser.</p>

                <p>I min implementation av en kortlek och spelkontroller användes arv för att skapa hierarki mellan klasser och komposition för att innehålla kort i en hand eller en kortlek. Implementationen är strukturerad och lättläst, men förbättringar kan göras i felhantering och validering. </p>

                <p>Att jobba med Symfony enligt MVC har varit lärorikt och har underlättat kodorganiseringen. Att separera modeller, vyer och kontroller gör koden mer skalbar och underhållbar. I detta kursmoment har jag fortsatt lära mig om objektorientering, jag har större förståelse för hur koden bör struktureras för att vara så lättläst som möjlgit.</p>
            </div>
            <div class="item">
                <h2 id="kmom03">Kmom03</h2>
                <p>Att använda flödesdiagram och pseudokod är ett bra sätt att få sin kod sstrukturerad innan man börjar skriva den. Dock läste jag inte hela upggiftsbeskrivningen innan jag började koda så hade redan skrivit en del kod innan jag började med min pseudokod. Men i framtiden kommer det vara till stor hjälp för en bätttre kodstruktur.</p>

                <p>För att lösa uppgiften använde jag de klasser jag hade sedan förra kursmomentet och jag skapade en ny controller GameController. Jag önskar dock att jag hade haftt lite bättre struktur på min kod för nu har jag skrivit onödigt myckett kod i controllern som jag borde skrivit i en egen modul. Jag ska kolla på att strukturera om koden lite för att göra den mer lättläst.</p>

                <p>Jag tycker att Symfony har varit lite krångligtt att förstå mig på men jag förstår det bättre och bättre för varje kursmoment. Det verkar som ett bra ramverk att använda när man väl förstår det. </p>

                <p>Det jag lärt mig från detta kursmoment är att försöka strukturera upp koden bättre innan man faktiskt börjar skriva den för att få en mer lättläst kod. Flödesschema och pseudokod kan hjälpa till med detta.</p>
            </div>
            <div class="item">
                <h2 id="kmom04">Kmom04</h2>
                <p>Jag tycker att PHPunit är ett bra sätt att testa sin kod. Väldigt bra funktion att man med coverage-funktionen kan se hur stor del av sin kod som är testad för att kunna förbättra sina enhetstester (test på test!). Jag lyckades ganska bra med täckningen och har 94% täckning på Lines, 95% täckning på Functions and Methods och 89% täckning på Classes and Traits. </p>

                <p>Där jag egentligen misslyckades med täckningen lite är i min GameController. Här hade jag behövt strukturera om min kode lite för att enklare kunna testa den med PHPunit. Här borde jag lägga över mer kod från Controllern till en egen modul för att göra koden mer lättläst och enklare att testa. </p>

                <p>Kod är enklare att testa då den är uppdelad i exempelvis metoder som alla har sin egen funktion. Att dela upp koden på detta sätt gör även koden mer lättläst och enklare att förstå så testbar kod har absolut direkt koppling till snygg och ren kod. </p>

                <p>Enhetstester är inget nytt för mig men PHPunit är vilket är ett effektivt och tydligt sätt att testa sin kod på.</p>
            </div>
            <div class="item">
                <h2 id="kmom05">Kmom05</h2>
                <p>Detta kursmomentet gick ganska snabbt och smidigt för mig, jag fastnade inte särskilt mycket på något ställe. Jag har valt att ha listan över alla böcker i biblioteket som landningssida och härifrån kan man lägga till böcker, visa detaljer om enskilda böcker samt redigera och radera böcker för att gränssnitten ska vara så användarvänligt som möjligt. </p>

                <p>Att arbeta med ORM kändes också bra och tydligt. Tidigare har jag behövss skriva långa SQL-koder för varenda förfrågan men med hjälp av ORM så blir koden mycket kortare och tydligare. Hela uppgiften gick väldigt snabbt att göra på grund av detta. ORM hjälper alltså till för att effektivisera kodskrivningen men ser även till att koden får en lättläst och kort struktur. </p>
            </div>
            <div class="item">
                <h2 id="kmom06">Kmom06</h2>
                <p>Jag tycker att phpmetric verkar som ett bra verktyg för att få en snabb översikt över ens kodkvalitet. Jag gillar bilden med cirklarna för att få en snabb översikt över hela ens kod. Violations är också ett bra sätt att se de största felen i min kod. De andra siffrorna är också användbara men dessa kollade jag mer översiktligt på.</p>
                <p>Scutinizer hade jag mer problem med. Jag hade problem att få mina inspections att gå igenom. Jag fick hålla på och ändra i min composer fil och andra små detaljer för att den skulle gå igenom. Jag fastnade många timmar på att mina enhetstester gick igenom för mig utan problem lokalt men ville inte gå igenom hos scrutinizer. Jag löste detta till slut genom att kommentera bort public/buil i min .gitignorefil så att kod som behövdes för testerna faktiskt laddades upp till github. Efter attt min första inspection till slut gått igenom så ficck jag en kodkvalitet på 6,88 och en kodtäcking på 58%. Kodtäckningen har jag nu höjt ca 20% efter att ha lagt till lite fler enhetstester.</p>
                <p>Jag tycker att båda verktygen verkar bra för att få en översikt över sin kod och jag förstår att det är viktigt att ha hög kodkvalitet, dock är kodtestning väldigt tidskrävande så jag hade svårt att vara motiverad i detta kursmoment. I och med att ingenting faktiskt ändras på webbplatsen, utan allt fungerade på webbplatsen som det skulle innan också, så kändes det som jag la onödigt mycket tid på att höja kodkvaliteten. Men jag förstår såklart varför det är viktigt, i framtiden tror jag dock att jag ska ha dessa tester i huvudet redan innan jag börja skriva koden. Det blir förmodligen lättare att på så sätt få bra kodkvalitet från början istället för att ändra koden i efterhand.</p>
            </div>
            <div class="item">
                <h2 id="kmom10">Kmom10</h2>
                <p>Jag har valt att göra ett äventyrsspel som slutprojekt. I detta spel vinner du genom att hitta och öppna skattkistan! Du börjar i en djungel och ska ta dig genom olika rum för att ta dig till skatten! Problemet? För att gå mellan de olika rummen måste du samla på dig vissa föremål, men du kan bara ha fem föremål i din ryggsäck samtidigt.</p>

                <p>För att göra grunden till projektet så skapade jag en controller. Jag använde mig sedan av servicemoduler för att minimera koden i controllern. Jag har en modul som hanterar spellogiken för att ta sig mellan rummen, en som hanterar spellogiken för alla föremål, en för att hantera mina jsonfiler, och en som kontrollerar om man har tillgång till ett rum man försöker ta sig till.</p>

                <p>När det kom till enhetstester av mina filer så stötte jag på lite problem. Jag lyckades fixa många tester och väldigt bra kodtäckning lokalt men alla tester som har med databasen att göra gick inte igenom på scrutinizer. Jag har felsökt, försökt ändra i .env-filer för att konfigurer SQLite till scrutinizer, och testat att skriva testen på många olika sätt men de gick fortfarande inte igenom. Detta innebär att min kodtäcking just nu är mycket sämre än jag hoppats på (70%) då stor del av min kod har med databasen att göra. </p>

                <p>För att uppfylla krav 4 så gjorde jag en till controller som hanterar all JSON API till projektet. Jag valde att skapa en JSON-fil för alla portalknappar och föremål som finns i de olika rummen. Detta för att det inte är något som en spelare ska kunna ändra eller lägga till men det är enkelt för spelutvecklaren att ändra i JSON-filerna. Varje portalknappar har tre värden: roomnumber, direction och toroom. Alla items har två värden: itemname och room. Jag valde att skapa 6 stycken routes för mitt JSON API. Det finns en route som visar alla föremål från JSON-filen och en route som visar knapparna. Sedan skapade jag fyra routes som har med min databas att göra. EN route visar alla spelare som finns i tabellen players och en visar alla föremål som spelarna har i sina ryggsäckar (tabellen items). Jag har även två POST-routes. En som lägger till ett föremål i en spelares ryggsäck och en som tar bort en. Det finns länkar till alla routes i /proj/api.</p>

                <p>För att uppfylla krav 5 skapade jag en databas med två tabeller: players och items. Tabellerna hanterar spelarinformation respektive föremål som spelare samlar på sig. Jag valde att använda SQLite som databas eftersom det är enkelt att konfigurera och passar bra för mindre projekt. För att visualisera databasens struktur skapade jag ett ER-diagram som visar relationerna mellan tabellerna. Jag lade till en bild av detta diagram på sidan proj/about/database. Tabellerna är enkla: players lagrar spelar-ID och spelarens namn, medan items lagrar föremåls-ID, spelar-ID, föremålsnamn och antal föremål. För att hantera relationen mellan tabellerna, använder jag spelarens ID som en främmande nyckel i items-tabellen. Jag genomförde enhetstester för att säkerställa att databasfunktionerna fungerar korrekt, men stötte på problem med att få dessa tester att fungera på Scrutinizer. Trots flera försök att konfigurera SQLite i Scrutinizer gick testerna inte igenom, vilket påverkade min totala kodtäckning negativt. För att länka till databassidan lade jag till en länk från proj/about till proj/about/database. </p>

                <p>Att använda en ORM som Doctrine i Symfony har sina fördelar. ORMs gör det enklare att hantera databasoperationer direkt i koden, utan att behöva skriva SQL-frågor. Detta sparar tid och minskar risken för fel. En nackdel är att ORMs kan skapa ineffektiva frågor som påverkar prestandan. Traditionella metoder ger mer kontroll över SQL-frågor och optimeringar, vilket kan förbättra prestandan i vissa fall. En stor fördel med ORM är dess förmåga att hantera komplexa relationer och erbjuda databasagnostiska lösningar, vilket gör applikationen mer flexibel och enklare att migrera mellan olika databassystem. Under databaskursen arbetade vi direkt med SQL, vilket gav en djupare förståelse för hur databaser fungerar. Båda metoderna har sina styrkor och svagheter. ORM är bra för snabb utveckling och underhåll, medan traditionell metod kan vara bättre för prestandakritiska applikationer. Valet beror på projektets behov och komplexitet.</p>

                <p>För krav 6 så har jag här tagit fram några avancerade features i mitt projekt. Tre saker som har varit extra svåra att ta fram men som jag är nöjd över i detta projekt är hur jag uppdelade data i JSON och databas i ORM, implementering av AccessControlService och sparning av användardata.</p>

                <p>I mitt projekt har jag effektivt utnyttjat både JSON-filer och en databas med hjälp av ORM (Object-Relational Mapping). JSON-filer används för att lagra data som inte behöver ändras dynamiskt under spelets gång, utan endast av spelutvecklaren. Detta inkluderar föremål och knappar som används i spelet. Å andra sidan används databasen för att lagra dynamiska data som uppdateras under spelets gång, såsom spelarens föremål och status. Genom att använda databasen kan jag enkelt hantera POST-förfrågningar och andra dynamiska interaktioner.</p>

                <p>För att säkerställa att spelaren måste ha vissa föremål i sin ryggsäck för att ta sig genom specifika rum, har jag implementerat en servicefil kallad AccessControlService. Denna service kontrollerar spelarens föremål och avgör om spelaren har tillgång till nästa rum eller inte genom att fråga tabellen items i databasen. Till exempel, spelaren måste ha en ficklampa för att gå in i grottan eller ett pass och pengar för att gå in i flygplanet. Detta tillägg har inte bara ökat spelets komplexitet och utmaning, utan också bidragit till en mer engagerande spelupplevelse.</p>

                <p>En annan viktig funktion jag har implementerat är möjligheten för spelaren att ange ett användarnamn vid spelets början. Detta gör att spelets data, inklusive spelarens ID och föremål i ryggsäcken, sparas individuellt för varje användare. Denna data kan sedan användas för statistik och analys av spelarnas beteende. Dessutom syns dessa användare och deras föremål i API:et, vilket möjliggör enkel åtkomst och manipulation av data via olika API-endpoints. Detta har skapat en mer personlig och dynamisk spelupplevelse.</p>

                <p>Överlag tycker jag att projektet gick okej. Det mesta gick hyfsat smidigt att genomföra med undantag för enhetstesterna som jag hade så mycket problem med. Jag hade även velat lägga mer tid på till exempel design. I en perfekt värld hade jag helst velat designa bakgrunder och föremål helt själv så att designen blivit mer sammanhängande. Detta hade dock tagit för lång tid så nu nöjer jag mig med hämtade bilder. Jag hade även velat lägga till fler pussel och features i spelet. Nu kan man samla på föremål och man behöver vissa föremål för att gå genom rummen, men det hade blivit ett roligare spel om man även behövde lösa andra pussel genom spelets gång.</p>

                <p>Jag tycker att denna kursen har varit intressant och rolig. I början kändes den väldigt svår och jag hade svårt att förstå mig på symfony. Efter varje kursmoment förstår jag det dock bättre och bättre och nu ser jag tydligt alla fördelar med att använda symfony. Jag tycker också att kursmomenten varit på lagom svår nivå och jag tyckte om att man fick lite större frihet i slutprojektet än vi fått i andra kurser. </p>

            </div>
        </div>
    </div>

</div>

<script>
    // Scroll to the specific course moment section if fragment is provided
    {% if fragment %}
        document.getElementById('{{ fragment }}').scrollIntoView();
    {% endif %}
</script>

{% endblock %}